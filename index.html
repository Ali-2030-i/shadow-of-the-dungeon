<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow of the Dungeon: Ascension</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }





        .control-group {
            position: absolute;
            bottom: 10px;
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        .left-controls {
            left: 20px;
        }

        .right-controls {
            right: 20px;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: rgba(255, 255, 255, 0.8);
            user-select: none;
            touch-action: none;
            backdrop-filter: blur(2px);
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        .rect-btn {
            border-radius: 15px;
            width: 80px;
        }

        /* --- Virtual Gamepad CSS --- */
        #virtualGamepad {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Let touches pass through to buttons but not block view */
            z-index: 1000;
            display: none;
            /* Hidden on desktop by default */
        }

        @media (hover: none) and (pointer: coarse) {
            #virtualGamepad {
                display: block;
            }
        }

        .d-pad,
        .action-pad {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 20px;
            pointer-events: auto;
            /* Enable touch on buttons */
        }

        .d-pad {
            left: 30px;
        }

        .action-pad {
            right: 30px;
        }

        .v-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            user-select: none;
            touch-action: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s, background 0.1s;
        }

        .v-btn:active {
            transform: scale(0.92);
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .btn-arrow {
            width: 70px;
            height: 70px;
            font-size: 32px;
            border-radius: 15px;
            /* Square-ish for arrows */
        }

        .btn-action {
            width: 80px;
            height: 80px;
            font-size: 24px;
        }

        .btn-attack {
            background: rgba(255, 50, 50, 0.2);
            border-color: rgba(255, 100, 100, 0.4);
            font-size: 32px;
        }

        /* Hint for landscape mode */
        @media screen and (orientation: portrait) {
            #virtualGamepad::after {
                content: "Best Played in Landscape!";
                position: absolute;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                color: rgba(255, 255, 255, 0.5);
                font-size: 14px;
                pointer-events: none;
            }
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="virtualGamepad">
        <div class="d-pad">
            <div class="v-btn btn-arrow" id="btnLeft">‚Üê</div>
            <div class="v-btn btn-arrow" id="btnRight">‚Üí</div>
        </div>
        <div class="action-pad">
            <div class="v-btn btn-action btn-attack" id="btnAttack">‚öîÔ∏è</div>
            <div class="v-btn btn-action" id="btnJump">ü¶ò</div>
        </div>
    </div>



    <script>
        // --- Constants & Config ---
        const GRAVITY = 0.6;
        const FRICTION = 0.82;
        const PLAYER_SPEED = 0.8;
        const PLAYER_MAX_SPEED = 7;
        const JUMP_FORCE = 13;
        const DOUBLE_JUMP_FORCE = 11;
        const ATTACK_DURATION = 18;
        const ATTACK_COOLDOWN = 25;
        const INVULNERABILITY_TIME = 80;

        const SCROLL_SPEED = 0.5; // Parallax
        const CAMERA_ZOOM = 0.65; // Zoom out factor (0.65 means we see ~50% more)

        const COLORS = {
            bg: '#050505',
            bgGradient1: '#1a1a1a',
            bgGradient2: '#000000',
            platformTop: '#1a1', // Toxic Green top
            platformBody: '#222',
            player: '#333',
            playerScarf: '#f22',
            ghoulBody: '#500',
            ghoulGlow: '#f00',
            batBody: '#203',
            batWing: '#506',
            spike: '#888',
            heart: '#e00',
            portalOne: '#0ff',
            portalTwo: '#f0f',
            slash: '#fff',
            textShadow: 'rgba(0,0,0,0.8)',
            shield: '#66aa99',
            shieldHit: '#aaf',
            mageBody: '#408',
            mageProjectile: '#a0f',
            kamikazeFlash: '#ff0',
            eliteGlow: '#f0f'
        };

        const SKINS = {
            DEFAULT: { id: 'DEFAULT', name: 'Wanderer', body: '#333', scarf: '#f22' },
            VETERAN: { id: 'VETERAN', name: 'Veteran (1000 Pts)', body: '#435', scarf: '#fd0', unlockScore: 1000 },
            SHADOW: { id: 'SHADOW', name: 'Shadow (100 Kills)', body: '#111', scarf: '#eee', unlockKills: 100 }
        };

        const BIOME_DATA = {
            DUNGEON: {
                bgGradient1: '#1a1a1a', bgGradient2: '#000000',
                platformTop: '#1a1', platformBody: '#222',
                friction: 0.82
            },
            LAVA: { // Levels 2-3
                bgGradient1: '#310', bgGradient2: '#100',
                platformTop: '#ca0', platformBody: '#410',
                friction: 0.82
            },
            ICE: { // Levels 4-5
                bgGradient1: '#012', bgGradient2: '#001',
                platformTop: '#aff', platformBody: '#224',
                friction: 0.96 // Low friction
            },
            VOID: { // Levels 6+
                bgGradient1: '#202', bgGradient2: '#000',
                platformTop: '#d0d', platformBody: '#101',
                friction: 0.82
            }
        };

        const ENEMY_STATE = {
            IDLE: 0,
            CHASE: 1,
            ATTACK: 2,
            RETREAT: 3,
            STUNNED: 4,
            DEAD: 5,
            BLOCK: 6
        };

        const UPGRADES = [
            { id: 'VITALITY', name: "Vitality", desc: "+1 Max HP & Full Heal" },
            { id: 'STRENGTH', name: "Strength", desc: "+Damage (Kill enemies faster)" },
            { id: 'AGILITY', name: "Agility", desc: "+20% Move Speed" },
            { id: 'REACH', name: "Reach", desc: "+30% Attack Range" },
            { id: 'HASTE', name: "Haste", desc: "-20% Attack Cooldown" }
        ];

        // --- Input Handling ---
        const keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, Space: false, KeyF: false };
        const keyPresses = { ArrowUp: false, Space: false, KeyF: false };

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = true;
                keyPresses[e.code] = true;
            }
            if (e.code === 'ArrowUp') keyPresses['Space'] = true;
            if (e.code === 'Space') keyPresses['ArrowUp'] = true;
            if (e.key === 't' || e.key === 'T') {
                if (game.state === 'START') {
                    // Cycle Skins
                    let unlocked = game.saveData.unlockedSkins;
                    let currentIdx = unlocked.indexOf(game.saveData.currentSkin);
                    let nextIdx = (currentIdx + 1) % unlocked.length;
                    let nextSkinName = unlocked[nextIdx];
                    game.saveData.currentSkin = nextSkinName;
                    game.skin = SKINS[nextSkinName];
                    SaveManager.save(game.saveData);
                }
            }
            if (e.key === 'Shift') {
                if (game.state === 'PLAYING' && game.player) {
                    game.player.triggerAbility();
                }
            }
        });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        // --- Virtual Gamepad Logic ---
        function setupButton(id, keyCodes) {
            const btn = document.getElementById(id);
            if (!btn) return;

            // Handle both touch and mouse for testing on desktop if needed
            const startHandler = (e) => {
                if (e.cancelable) e.preventDefault();
                keyCodes.forEach(k => {
                    keys[k] = true;
                    keyPresses[k] = true;
                });
                // Haptic feedback if available
                if (window.navigator && window.navigator.vibrate) window.navigator.vibrate(5);
            };

            const endHandler = (e) => {
                if (e.cancelable) e.preventDefault();
                keyCodes.forEach(k => keys[k] = false);
            };

            btn.addEventListener('touchstart', startHandler, { passive: false });
            btn.addEventListener('touchend', endHandler, { passive: false });
            btn.addEventListener('touchcancel', endHandler, { passive: false });

            // Mouse/Click Fallback for clicking with mouse
            btn.addEventListener('mousedown', startHandler);
            btn.addEventListener('mouseup', endHandler);
            btn.addEventListener('mouseleave', endHandler);
        }


        // --- Sound Init Hook ---
        const initSound = () => { SoundManager.init(); window.removeEventListener('click', initSound); window.removeEventListener('keydown', initSound); };
        window.addEventListener('click', initSound);
        window.addEventListener('keydown', initSound);
        window.addEventListener('touchstart', initSound);

        setupButton('btnLeft', ['ArrowLeft']);
        setupButton('btnRight', ['ArrowRight']);
        setupButton('btnJump', ['ArrowUp', 'Space']);
        setupButton('btnAttack', ['KeyF']);

        // Global Touch Handler for Start/Restart (Tap anywhere NOT on a button)
        window.addEventListener('touchstart', (e) => {
            // Check if target is a button
            if (e.target.closest('.v-btn')) return;

            if (game.state !== 'PLAYING') {
                if (game.state === 'LEVEL_UP') {
                    game.handleLevelUpClick(e.touches[0].clientX, e.touches[0].clientY);
                } else {
                    game.triggerRestart = true;
                }
            }
        }, { passive: false });

        // Prevent default touch actions (scrolling/zooming) on the game interface
        document.addEventListener('gesturestart', (e) => { e.preventDefault(); });

        // --- Math & Helpers ---
        class Vector2 { constructor(x, y) { this.x = x; this.y = y; } }
        class Box {
            constructor(x, y, w, h) {
                this.pos = new Vector2(x, y);
                this.w = w; this.h = h;
            }
            overlaps(other) {
                return (this.pos.x < other.pos.x + other.w && this.pos.x + this.w > other.pos.x &&
                    this.pos.y < other.pos.y + other.h && this.pos.y + this.h > other.pos.y);
            }
        }

        class MovingPlatform extends Box {
            constructor(x, y, w, h, rangeX, rangeY, speed) {
                super(x, y, w, h);
                this.startPos = new Vector2(x, y);
                this.rangeX = rangeX;
                this.rangeY = rangeY;
                this.speed = speed;
                this.time = Math.random() * 100;
                this.delta = new Vector2(0, 0);
            }
            update() {
                this.time += this.speed;
                let prevX = this.pos.x;
                let prevY = this.pos.y;

                if (this.rangeX > 0) this.pos.x = this.startPos.x + Math.sin(this.time) * this.rangeX;
                if (this.rangeY > 0) this.pos.y = this.startPos.y + Math.sin(this.time) * this.rangeY;

                // Collision with Static Platforms (Naive Bounce/Clamp)
                // If we hit a platform, we should clamp position to be outside
                if (game.level) {
                    for (let p of game.level.platforms) {
                        // Optimization: Skip if far away X
                        if (this.pos.x + this.w + 100 < p.pos.x || this.pos.x - 100 > p.pos.x + p.w) continue;

                        if (this.overlaps(p)) {
                            // Simple fix: If moving X, clamp to side.
                            if (this.rangeX > 0) {
                                if (this.pos.x < p.pos.x + p.w && this.pos.x + this.w > p.pos.x) {
                                    if (prevX + this.w <= p.pos.x) { this.pos.x = p.pos.x - this.w - 1; } // Hit Left
                                    else if (prevX >= p.pos.x + p.w) { this.pos.x = p.pos.x + p.w + 1; } // Hit Right
                                }
                            }
                        }
                    }
                }

                this.delta.x = this.pos.x - prevX;
                this.delta.y = this.pos.y - prevY;
            }
            draw(ctx) {
                ctx.fillStyle = COLORS.platformBody;
                ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);

                // Gears
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(this.pos.x + 10, this.pos.y + this.h / 2, 6, 0, Math.PI * 2);
                ctx.arc(this.pos.x + this.w - 10, this.pos.y + this.h / 2, 6, 0, Math.PI * 2);
                ctx.fill();

                // Top
                ctx.fillStyle = COLORS.platformTop;
                ctx.fillRect(this.pos.x, this.pos.y, this.w, 4);
            }
        }

        class CrumblingPlatform extends Box {
            constructor(x, y, w, h) {
                super(x, y, w, h);
                this.triggered = false;
                this.crumbleTimer = 30; // 0.5 sec shake then fall
                this.fallen = false;
                this.origPos = new Vector2(x, y);
            }
            trigger() {
                if (!this.triggered) {
                    this.triggered = true;
                    SoundManager.playTone(100, 'sawtooth', 0.1, 0.1); // Crack sound
                }
            }
            update() {
                if (this.triggered && !this.fallen) {
                    this.crumbleTimer--;
                    // Shake
                    this.pos.x = this.origPos.x + (Math.random() * 4 - 2);
                    this.pos.y = this.origPos.y + (Math.random() * 4 - 2);

                    if (this.crumbleTimer <= 0) {
                        this.fallen = true;
                    }
                } else if (this.fallen) {
                    this.pos.y += 10; // Fall fast
                } else {
                    this.pos.x = this.origPos.x;
                    this.pos.y = this.origPos.y;
                }
            }
            draw(ctx) {
                if (this.fallen && this.pos.y > 1000) return;

                ctx.fillStyle = this.triggered ? '#655' : COLORS.platformBody;
                ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);

                // Cracks
                if (this.triggered) {
                    ctx.strokeStyle = '#000';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x + 5, this.pos.y);
                    ctx.lineTo(this.pos.x + 15, this.pos.y + 20);
                    ctx.lineTo(this.pos.x + 35, this.pos.y + 5);
                    ctx.stroke();
                }

                ctx.fillStyle = COLORS.platformTop;
                ctx.fillRect(this.pos.x, this.pos.y, this.w, 3);
            }
        }

        // --- Trap System ---
        class Trap extends Box {
            constructor(x, y, w, h) {
                super(x, y, w, h);
                this.active = false;
                this.damage = 1;
            }
            update() { }
            draw(ctx) { }
            checkCollision(player) {
                if (this.active && this.overlaps(player)) {
                    player.takeDamage(this.damage);
                    return true;
                }
                return false;
            }
        }

        class BladeTrap extends Trap {
            constructor(x, y) {
                super(x, y, 40, 40);
                this.timer = 0;
                this.cycle = 120; // 60 idle, 30 windup, 30 active
                this.bladeHeight = 0;
            }
            update() {
                this.timer++;
                if (this.timer >= this.cycle) this.timer = 0;

                // 0-60: Idle
                // 60-90: Windup (Shake)
                // 90-120: Active (Blade Up)

                if (this.timer > 60 && this.timer < 90) {
                    // Windup
                    this.active = false;
                } else if (this.timer >= 90) {
                    // Active
                    this.active = true;
                    this.bladeHeight = 30;
                } else {
                    this.active = false;
                    this.bladeHeight = 0;
                }
            }
            draw(ctx) {
                ctx.fillStyle = '#444';
                ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h); // Base

                // Blade
                if (this.timer > 60) {
                    let h = this.active ? 35 : (this.timer - 60); // Grow during windup
                    ctx.fillStyle = this.active ? '#f00' : '#ccc';
                    if (this.active) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#f00';
                    }

                    // Shake
                    let shake = (this.timer > 60 && this.timer < 90) ? (Math.random() * 4 - 2) : 0;

                    ctx.beginPath();
                    ctx.moveTo(this.pos.x + 10 + shake, this.pos.y);
                    ctx.lineTo(this.pos.x + 20 + shake, this.pos.y - h);
                    ctx.lineTo(this.pos.x + 30 + shake, this.pos.y);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            checkCollision(player) {
                // Override to check blade rect, not base rect
                if (this.active) {
                    let bladeBox = new Box(this.pos.x + 5, this.pos.y - 35, 30, 35);
                    if (bladeBox.overlaps(player)) {
                        player.takeDamage(1);
                        player.vel.y = -8; // Knock up
                        return true;
                    }
                }
                return false;
            }
        }

        class PressurePlateTrap extends Trap {
            constructor(x, y) {
                super(x, y + 15, 30, 5); // Flat on ground
                this.color = '#aa0';
                this.triggered = false;
                this.resetTimer = 0;
            }
            update() {
                if (this.triggered) {
                    this.resetTimer--;
                    if (this.resetTimer <= 0) {
                        this.triggered = false;
                        this.active = false;
                        this.y -= 5; // Pop up
                    }
                }
            }
            checkCollision(player) {
                if (!this.triggered && this.overlaps(player) && player.grounded) {
                    this.trigger();
                }
                // Doesn't deal damage directly, spawns hazard
                return false;
            }
            trigger() {
                this.triggered = true;
                this.resetTimer = 100;
                this.y += 5; // Press down
                SoundManager.playTone(600, 'square', 0.05, 0.05);

                // Spawn projectile above
                game.projectiles.push(new Projectile(this.pos.x + 15, this.pos.y - 200, 0, 8, 'TRAP'));
            }
            draw(ctx) {
                ctx.fillStyle = this.triggered ? '#550' : this.color;
                ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);
            }
        }

        class LaserTrap extends Trap {
            constructor(x, y, range, vertical = false) {
                super(x, y, vertical ? 10 : range, vertical ? range : 10);
                this.range = range;
                this.vertical = vertical;
                this.timer = 0;
            }
            update() {
                this.timer += 0.05;
                this.active = true;
            }
            draw(ctx) {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f0f';
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 4 + Math.sin(Date.now() / 100) * 2;

                ctx.beginPath();
                if (this.vertical) {
                    ctx.moveTo(this.pos.x + 5, this.pos.y);
                    ctx.lineTo(this.pos.x + 5, this.pos.y + this.h);
                } else {
                    ctx.moveTo(this.pos.x, this.pos.y + 5);
                    ctx.lineTo(this.pos.x + this.w, this.pos.y + 5);
                }
                ctx.stroke();
                ctx.restore();

                // Emitters
                ctx.fillStyle = '#333';
                if (this.vertical) {
                    ctx.fillRect(this.pos.x, this.pos.y - 10, 10, 10);
                    ctx.fillRect(this.pos.x, this.pos.y + this.h, 10, 10);
                } else {
                    ctx.fillRect(this.pos.x - 10, this.pos.y, 10, 10);
                    ctx.fillRect(this.pos.x + this.w, this.pos.y, 10, 10);
                }
            }
        }

        // --- Objective System ---
        class Objective extends Box {
            constructor(x, y, w, h) {
                super(x, y, w, h);
                this.active = false;
                this.completed = false;
                this.rewarded = false;
                this.description = "Objective";
            }
            update() { }
            draw(ctx) { }
            complete() {
                if (this.completed) return;
                this.completed = true;
                SoundManager.playTone(600, 'triangle', 0.5, 0.4); // Success sound
                game.floatingTexts.push(new FloatingText(game.player.pos.x, game.player.pos.y - 50, "OBJECTIVE COMPLETE!", "#ffd700"));

                // Spawn Reward
                game.objects.push(new RewardChest(this.pos.x + this.w / 2 - 20, this.pos.y + this.h - 40));
            }
        }

        class KillChallenge extends Objective {
            constructor(x, y, w, h, targetCount) {
                super(x, y, w, h);
                this.targetCount = targetCount;
                this.kills = 0;
                this.description = "Defeat Enemies!";
                this.triggered = false;
                this.enemiesToSpawn = [];
            }
            update() {
                if (this.completed) return;

                // Check player entry
                if (!this.triggered && this.overlaps(game.player)) {
                    this.triggered = true;
                    this.active = true;
                    game.floatingTexts.push(new FloatingText(game.player.pos.x, game.player.pos.y - 50, "CHALLENGE START!", "#f00"));

                    // Spawn Enemies
                    this.enemiesToSpawn.forEach(e => game.enemies.push(e));
                }

                if (this.triggered) {
                    // Track kills? 
                    // Needs Game to track kills associated with this room? 
                    // Simplified: Just check if the specific enemies spawned are dead.
                    let allDead = true;
                    for (let e of this.enemiesToSpawn) {
                        if (!e.dead) {
                            allDead = false;
                            break;
                        }
                    }
                    if (this.enemiesToSpawn.length > 0 && allDead) {
                        this.complete();
                    }
                }
            }
            draw(ctx) {
                if (this.completed) return;

                // Draw Zone Border
                ctx.strokeStyle = this.triggered ? '#f00' : '#ff0';
                ctx.setLineDash([10, 10]);
                ctx.strokeRect(this.pos.x, this.pos.y, this.w, this.h);
                ctx.setLineDash([]);

                // Draw Text
                if (this.overlaps(game.player) || this.triggered) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '16px Segoe UI';
                    let remaining = 0;
                    for (let e of this.enemiesToSpawn) if (!e.dead) remaining++;
                    ctx.fillText(`${this.description} (${remaining})`, this.pos.x + 20, this.pos.y + 30);
                }
            }
        }

        // --- Arena System ---
        class ArenaGate extends Box {
            constructor(x, y, h) {
                super(x, y, 20, h);
                this.locked = false;
                this.activeHeight = h;
                this.timer = 0;
            }
            lock() {
                this.locked = true;
                // Add to game platforms if not already? 
                // Using a persistent reference approach or management by Controller is safer
            }
            unlock() {
                this.locked = false;
            }
            draw(ctx) {
                if (!this.locked && this.timer <= 0) return; // Invisible when open

                ctx.fillStyle = '#555';
                // Animate closing/opening?
                let h = this.locked ? this.activeHeight : 0;
                ctx.fillRect(this.pos.x, this.pos.y, this.w, h);

                // Bars
                if (this.locked) {
                    ctx.strokeStyle = '#000';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x + 10, this.pos.y);
                    ctx.lineTo(this.pos.x + 10, this.pos.y + h);
                    ctx.stroke();
                }
            }
        }

        class ArenaController extends Objective {
            constructor(x, y, w, h) {
                super(x, y, w, h);
                this.description = "Survive the Arena!";
                this.waves = []; // Array of Arrays of Enemy Classes
                this.currentWaveIdx = 0;
                this.waveEnemies = [];
                this.gates = []; // [Gate, Gate]
                this.state = 'IDLE'; // IDLE, ACTIVE, DELAY, CLEARED
                this.delayTimer = 0;
            }
            addWave(enemies) {
                this.waves.push(enemies);
            }
            update() {
                if (this.state === 'CLEARED') return;

                if (this.state === 'IDLE') {
                    if (this.overlaps(game.player)) {
                        this.startArena();
                    }
                } else if (this.state === 'ACTIVE') {
                    // Check Wave Clear
                    let allDead = true;
                    for (let e of this.waveEnemies) {
                        if (!e.dead) { allDead = false; break; }
                    }

                    if (allDead) {
                        this.currentWaveIdx++;
                        if (this.currentWaveIdx >= this.waves.length) {
                            this.clearArena();
                        } else {
                            this.state = 'DELAY';
                            this.delayTimer = 60; // 1s delay
                            game.floatingTexts.push(new FloatingText(game.player.pos.x, game.player.pos.y - 80, "WAVE CLEARED!", "#0f0"));
                        }
                    }
                } else if (this.state === 'DELAY') {
                    this.delayTimer--;
                    if (this.delayTimer <= 0) {
                        this.spawnWave();
                    }
                }
            }
            startArena() {
                this.state = 'ACTIVE';
                this.gates.forEach(g => {
                    g.lock();
                    game.level.platforms.push(g); // Become Solid
                });
                SoundManager.playTone(100, 'sawtooth', 0.5, 0.5); // Slam
                game.floatingTexts.push(new FloatingText(game.player.pos.x, game.player.pos.y - 50, "ARENA LOCKED!", "#f00"));
                this.spawnWave();
            }
            spawnWave() {
                this.state = 'ACTIVE';
                let wave = this.waves[this.currentWaveIdx];
                this.waveEnemies = [];

                wave.forEach((EnemyClass, i) => {
                    // Spawn uniformly across arena width
                    let ex = this.pos.x + 50 + Math.random() * (this.w - 100);
                    let ey = this.pos.y + this.h - 50; // Floor level roughly
                    let e = new EnemyClass(ex, ey);
                    game.enemies.push(e);
                    this.waveEnemies.push(e);
                    // Spawn Effect
                    game.particles.push(new Particle(ex, ey, '#f0f', 3, 3, 30));
                });
                game.floatingTexts.push(new FloatingText(game.player.pos.x, game.player.pos.y - 100, `WAVE ${this.currentWaveIdx + 1}!`, "#fff"));
            }
            clearArena() {
                this.state = 'CLEARED';
                this.completed = true;
                this.gates.forEach(g => {
                    g.unlock();
                    // Remove from physics
                    let idx = game.level.platforms.indexOf(g);
                    if (idx > -1) game.level.platforms.splice(idx, 1);
                });
                SoundManager.playTone(600, 'triangle', 0.5, 0.5);
                game.floatingTexts.push(new FloatingText(game.player.pos.x, game.player.pos.y - 50, "ARENA CLEARED!", "#ffd700"));

                // Reward
                game.objects.push(new RewardChest(this.pos.x + this.w / 2, this.pos.y + this.h - 40));
            }
            draw(ctx) {
                // Draw Gates
                this.gates.forEach(g => g.draw(ctx));

                if (this.state !== 'IDLE' && this.state !== 'CLEARED') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);

                    ctx.fillStyle = '#fff';
                    ctx.font = '20px Segoe UI';
                    ctx.fillText(`ARENA: WAVE ${this.currentWaveIdx + 1}/${this.waves.length}`, this.pos.x + this.w / 2 - 60, this.pos.y + 40);
                }
            }
        }

        class RewardChest extends Box {
            constructor(x, y) {
                super(x, y, 40, 30);
                this.opened = false;
                this.color = '#d4af37'; // Gold
            }
            update() {
                if (!this.opened && this.overlaps(game.player)) {
                    this.open();
                }
            }
            open() {
                this.opened = true;
                SoundManager.playTone(800, 'sine', 0.5, 0.5); // Open sound
                game.addXp(200);
                game.floatingTexts.push(new FloatingText(this.pos.x, this.pos.y - 20, "+200 XP", "#0f0"));

                // Maybe a heal?
                if (!game.modifiers.noHealing && game.player.health < game.player.maxHealth) {
                    game.player.health++;
                    game.floatingTexts.push(new FloatingText(this.pos.x + 20, this.pos.y - 40, "+1 HP", "#f00"));
                }
            }
            draw(ctx) {
                if (this.opened) {
                    ctx.fillStyle = '#654'; // Darker wood
                    ctx.fillRect(this.pos.x, this.pos.y + 15, 40, 15); // Open bottom
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.pos.x + 2, this.pos.y + 2, 36, 13); // Local void
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.pos.x, this.pos.y, 40, 30);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.pos.x + 18, this.pos.y + 10, 4, 10); // Lock
                }
            }
        }

        // --- Ability System ---
        class Ability {
            constructor(name, cooldown, icon) {
                this.name = name;
                this.maxCooldown = cooldown;
                this.cooldownTimer = 0;
                this.activeDuration = 0;
                this.timer = 0;
                this.icon = icon || '?';
            }
            canTrigger() {
                return this.cooldownTimer <= 0;
            }
            trigger(player) {
                // Override
                this.cooldownTimer = this.maxCooldown;
            }
            update(player) {
                if (this.cooldownTimer > 0) this.cooldownTimer--;
                if (this.timer > 0) {
                    this.timer--;
                    this.activeUpdate(player);
                }
            }
            activeUpdate(player) { }
            draw(ctx, player) { }
        }

        class DashAbility extends Ability {
            constructor() {
                super('Dash', 60, '>>'); // 1s cooldown
                this.activeDuration = 12; // 0.2s
            }
            trigger(player) {
                if (!this.canTrigger()) return;
                super.trigger(player);
                this.timer = this.activeDuration;

                // Dash Logic
                let dir = player.facingRight ? 1 : -1;
                // If moving, use input dir
                if (Math.abs(player.vel.x) > 0.1) dir = Math.sign(player.vel.x);

                player.vel.x = dir * 15;
                player.vel.y = 0;
                player.isDashing = true;
                SoundManager.playTone(600, 'sawtooth', 0.1, 0.1);

                // Trail effect
                for (let i = 0; i < 5; i++) {
                    game.particles.push(new Particle(player.pos.x, player.pos.y, '#fff', 5, 2, 20));
                }
            }
            activeUpdate(player) {
                player.vel.y = 0; // Anti-gravity
                if (this.timer === 1) {
                    player.isDashing = false;
                    player.vel.x *= 0.2; // Stop
                }
                // Spawn particles
                if (this.timer % 3 === 0) {
                    game.particles.push(new Particle(player.pos.x, player.pos.y, '#0ff', 4, 0, 10));
                }
            }
        }

        class ParryAbility extends Ability {
            constructor() {
                super('Parry', 120, 'P'); // 2s cooldown
                this.activeDuration = 15; // 0.25s window
            }
            trigger(player) {
                if (!this.canTrigger()) return;
                super.trigger(player);
                this.timer = this.activeDuration;
                player.isParrying = true;
                player.vel.x = 0; // Root
                SoundManager.playTone(800, 'square', 0.1, 0.05); // Ping

                game.floatingTexts.push(new FloatingText(player.pos.x, player.pos.y - 40, "!", "#fff"));
            }
            activeUpdate(player) {
                player.vel.x = 0;
                if (this.timer === 1) {
                    player.isParrying = false;
                }
            }
        }

        // --- Visual Effects ---
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 40;
                this.alpha = 1;
            }
            update() {
                this.y -= 0.6;
                this.life--;
                this.alpha = this.life / 40;
            }
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 16px Segoe UI';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 2;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        const SoundManager = {
            ctx: null,
            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playJump() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },
            playHit() { // Player damaged
                this.playTone(100, 'sawtooth', 0.2, 0.2);
            },
            playEnemyHit() {
                this.playTone(200, 'square', 0.1, 0.1);
            },
            playKill() {
                if (!this.ctx) return;
                // Simple noise burst approximation using multiple oscillators
                for (let i = 0; i < 3; i++) {
                    this.playTone(100 + Math.random() * 200, 'sawtooth', 0.2, 0.1);
                }
            }
        };

        const SaveManager = {
            load() {
                let data = localStorage.getItem('sotd_save');
                if (data) return JSON.parse(data);
                return { highScore: 0, totalKills: 0, unlockedSkins: ['DEFAULT'], currentSkin: 'DEFAULT' };
            },
            save(data) {
                localStorage.setItem('sotd_save', JSON.stringify(data));
            },
            checkUnlocks(data) {
                if (data.highScore >= 1000 && !data.unlockedSkins.includes('VETERAN')) {
                    data.unlockedSkins.push('VETERAN');
                    game.floatingTexts.push(new FloatingText(game.canvas.width / 2, 200, "SKIN UNLOCKED: VETERAN", "#fd0"));
                }
                // Mock kill verification
                // if (data.totalKills >= 100 ...)
            }
        };

        // --- Entities ---
        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x; this.y = y;
                this.color = color;
                this.size = size;
                let angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = life; this.maxLife = life;
                this.decay = Math.random() * 0.1 + 0.9; // Friction
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= this.decay; this.vy *= this.decay;
                this.life--;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        // --- Entities ---
        class Entity extends Box {
            constructor(x, y, w, h) {
                super(x, y, w, h);
                this.vel = new Vector2(0, 0);
                this.grounded = false;
                this.markedForDeletion = false;
                this.stunned = 0;
                this.currentPlatform = null;
            }
            update() {
                if (this.stunned > 0) { this.stunned--; return; } // Stun logic
                this.vel.y += GRAVITY;
                this.pos.x += this.vel.x;

                // Platform Movement
                if (this.currentPlatform) {
                    this.pos.x += this.currentPlatform.delta.x;
                    this.pos.y += this.currentPlatform.delta.y;
                }

                this.checkCollisions(true);
                this.pos.y += this.vel.y;
                this.grounded = false;
                this.currentPlatform = null; // Reset, re-detected in checkCollisions
                this.checkCollisions(false);
            }
            checkCollisions(horizontal) {
                if (!game.level) return;
                // Optimization: Only check platforms near the entity?
                // For now, simple loop is fine for < 100 platforms per frame visible
                for (let platform of game.level.platforms) {
                    // Simple optimization: x check first
                    if (this.pos.x + this.w + 50 < platform.pos.x || this.pos.x - 50 > platform.pos.x + platform.w) continue;

                    if (this.overlaps(platform)) {
                        if (horizontal) {
                            if (this.vel.x > 0) this.pos.x = platform.pos.x - this.w;
                            else if (this.vel.x < 0) this.pos.x = platform.pos.x + platform.w;
                            this.vel.x = 0;
                        } else {
                            if (this.vel.y > 0) {
                                this.pos.y = platform.pos.y - this.h;
                                this.grounded = true;
                            } else if (this.vel.y < 0) {
                                this.pos.y = platform.pos.y + platform.h;
                            }
                            this.vel.y = 0;
                        }
                    }
                }

                // Check Special Platforms
                if (game.level) {
                    for (let mp of game.level.movingPlatforms) {
                        // Allow standing on top, but moving through from bottom/sides is okay for simplicity or solid?
                        // Let's treat as solid for now similar to regular plats
                        if (this.overlaps(mp)) {
                            if (horizontal) {
                                if (this.vel.x > 0) this.pos.x = mp.pos.x - this.w;
                                else if (this.vel.x < 0) this.pos.x = mp.pos.x + mp.w;
                                this.vel.x = 0;
                            } else {
                                if (this.vel.y > 0 && this.pos.y + this.h < mp.pos.y + mp.h) { // Landing on top
                                    this.pos.y = mp.pos.y - this.h;
                                    this.grounded = true;
                                    this.currentPlatform = mp; // Latch onto platform
                                    this.vel.y = 0;
                                } else if (this.vel.y < 0) {
                                    this.pos.y = mp.pos.y + mp.h;
                                    this.vel.y = 0;
                                }
                            }
                        }
                    }

                    for (let cp of game.level.crumblingPlatforms) {
                        if (!cp.fallen && this.overlaps(cp)) {
                            // Fixed Trigger Logic: Check position, not just velocity
                            if (!horizontal && this.pos.y + this.h <= cp.pos.y + 10) {
                                this.pos.y = cp.pos.y - this.h;
                                this.grounded = true;
                                this.vel.y = 0;
                                cp.trigger();
                            }
                        }
                    }
                }
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 30, 50);
                this.jumpCount = 0;
                this.facingRight = true;
                this.attackTimer = 0;
                this.attackCooldown = 0;
                this.invulnerable = 0;
                this.health = 3; // Max health can increase?
                this.maxHealth = 3;
                this.animTimer = 0;
            }
            update() {
                // Input
                let speed = PLAYER_SPEED * (this.speedMult || 1);
                if (keys.ArrowRight) {
                    this.vel.x += speed;
                    this.facingRight = true;
                    this.animTimer++;
                } else if (keys.ArrowLeft) {
                    this.vel.x -= speed;
                    this.facingRight = false;
                    this.animTimer++;
                } else {
                    // Biome Friction
                    let currentFriction = (game.level && game.level.biome) ? game.level.biome.friction : FRICTION;
                    this.vel.x *= currentFriction;
                    this.animTimer = 0;
                }
                if (Math.abs(this.vel.x) > PLAYER_MAX_SPEED) this.vel.x = Math.sign(this.vel.x) * PLAYER_MAX_SPEED;
                if (Math.abs(this.vel.x) < 0.1) this.vel.x = 0;

                // Jump
                if ((keyPresses.Space || keyPresses.ArrowUp)) {
                    if (this.grounded) {
                        this.vel.y = -JUMP_FORCE;
                        this.jumpCount = 1;
                        this.spawnDust();
                        SoundManager.playJump();
                    } else if (this.jumpCount < 2) {
                        this.vel.y = -DOUBLE_JUMP_FORCE;
                        this.jumpCount++;
                        this.spawnDust();
                        SoundManager.playJump();
                    }
                    keyPresses.Space = false; keyPresses.ArrowUp = false;
                }

                // Attack
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (keyPresses.KeyF && this.attackCooldown <= 0) {
                    this.attackTimer = ATTACK_DURATION;
                    let cd = ATTACK_COOLDOWN * (this.cooldownMult || 1);
                    this.attackCooldown = cd;
                    this.checkAttackHit();
                    keyPresses.KeyF = false;
                    // Lunge forward slightly
                    this.vel.x += (this.facingRight ? 5 : -5);
                }
                if (this.attackTimer > 0) this.attackTimer--;

                if (this.invulnerable > 0) this.invulnerable--;
                super.update();
                if (this.grounded) this.jumpCount = 0;

                // Hazard Collision
                if (game.level) {
                    for (let spike of game.level.spikes) {
                        if (this.overlaps(spike)) {
                            this.takeDamage(1);
                            this.vel.y = -10;
                            this.vel.x = -this.vel.x * 1.5;
                        }
                    }
                    if (game.level.portal && this.overlaps(game.level.portal)) game.nextLevel();
                }

                if (this.pos.y > 1000) this.takeDamage(999); // Fall death

                // Enemy Collision
                if (this.attackTimer > 0) return; // Attack Immunity (Secondary Requirement)

                for (let enemy of game.enemies) {
                    // Contact Damage Rule: Only if NOT Stunned and NOT Dead
                    if (this.overlaps(enemy) && this.invulnerable <= 0 && !enemy.dead && enemy.state !== ENEMY_STATE.STUNNED) {
                        this.takeDamage(1);
                        this.vel.x = (this.pos.x < enemy.pos.x) ? -12 : 12;
                        this.vel.y = -6;
                    }
                }
            }
            takeDamage(amount) {
                if (this.invulnerable > 0 || game.state !== 'PLAYING') return;
                this.health -= amount;
                this.invulnerable = INVULNERABILITY_TIME;
                game.shakeScreen(15);
                game.freezeFrames = 10;
                game.floatingTexts.push(new FloatingText(this.pos.x + this.w / 2, this.pos.y, "-1 HP", "#f00"));
                SoundManager.playHit();
                if (this.health <= 0) game.gameOver();
            }
            checkAttackHit() {
                let range = 80 * (this.reachMult || 1);
                let hitX = this.facingRight ? this.pos.x + this.w : this.pos.x - range;
                let hitBox = new Box(hitX, this.pos.y - 10, range, this.h + 20); // Larger hitbox
                let hit = false;
                for (let enemy of game.enemies) {
                    if (hitBox.overlaps(enemy) && !enemy.dead) {
                        // Check if ShieldGoblin blocked from front
                        let attackFromRight = this.pos.x < enemy.pos.x; // Player is to the left of enemy (attacking RIGHT)
                        // Wait, 'fromRight' argument meant 'is damage source right of entity?'
                        // No, let's pass 'isPlayerRightOfEnemy'

                        let successfulHit = false;
                        if (typeof enemy.takeHit === 'function') {
                            let dmg = 1 * (this.damageMult || 1);
                            successfulHit = enemy.takeHit(dmg, this.pos.x > enemy.pos.x);
                        } else {
                            // Fallback
                            enemy.die();
                            successfulHit = true;
                        }

                        if (successfulHit) {
                            SoundManager.playKill();
                        } else {
                            // Blocked logic handled inside takeHit
                            game.freezeFrames = 2; // Small freeze for block
                        }
                    }
                }
                if (hit) game.shakeScreen(6);
            }
            spawnDust() {
                for (let i = 0; i < 5; i++) game.particles.push(new Particle(this.pos.x + this.w / 2, this.pos.y + this.h, '#aaa', 2, 4, 15));
            }
            draw(ctx) {
                if (this.invulnerable > 0 && Math.floor(Date.now() / 80) % 2 === 0) return;
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);
                if (!this.facingRight) ctx.scale(-1, 1);

                // Cape/Cloak Physics
                let speedRatio = this.vel.x / PLAYER_MAX_SPEED;
                let capeLift = -Math.abs(speedRatio) * 15;
                if (!this.grounded) capeLift -= 10;

                if (!this.grounded) capeLift -= 10;

                // Skin Colors
                let bodyColor = game.skin ? game.skin.body : COLORS.player;
                let scarfColor = game.skin ? game.skin.scarf : COLORS.playerScarf;

                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.moveTo(-10, -20); // Neck
                ctx.quadraticCurveTo(-25, 0 + capeLift, -20, 30 + capeLift); // Back of cape
                ctx.lineTo(15, 25); // Front bottom
                ctx.lineTo(10, -20); // Front neck
                ctx.fill();

                // Head
                ctx.fillStyle = '#111';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(0, -20, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Scarf
                ctx.strokeStyle = scarfColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.quadraticCurveTo(-15, -15, -25 + (speedRatio * -10), -5 + Math.sin(Date.now() / 100) * 5);
                ctx.stroke();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(2, -22); ctx.lineTo(10, -20); ctx.lineTo(4, -18); ctx.fill();

                // Legs
                if (this.grounded && Math.abs(this.vel.x) > 0.5) {
                    let legFactor = Math.sin(this.animTimer * 0.5) * 12;
                    ctx.strokeStyle = '#111';
                    ctx.beginPath(); ctx.moveTo(-5, 20); ctx.lineTo(-8 - legFactor, 40); ctx.stroke(); // Back leg
                    ctx.beginPath(); ctx.moveTo(5, 20); ctx.lineTo(8 + legFactor, 40); ctx.stroke(); // Front leg
                } else if (!this.grounded) {
                    ctx.strokeStyle = '#111';
                    ctx.beginPath(); ctx.moveTo(-5, 20); ctx.lineTo(-10, 35); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(5, 20); ctx.lineTo(10, 30); ctx.stroke();
                }

                // Sword Slash
                if (this.attackTimer > 0) {
                    let p = 1 - (this.attackTimer / ATTACK_DURATION); // 0 to 1
                    ctx.strokeStyle = COLORS.slash;
                    ctx.lineWidth = 4 - (p * 3);
                    ctx.beginPath();
                    ctx.arc(10, -10, 50, -Math.PI / 2 + (p * Math.PI), -Math.PI / 2 + (p * Math.PI) + Math.PI / 3);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 40, 60);
                this.color = '#fff'; // Placeholder
                this.speed = 5;
                this.jumpForce = -15;
                this.attackCooldown = 0;
                this.health = 3;
                this.maxHealth = 3;
                this.invulnerable = 0;

                // Ability System
                this.activeAbility = null; // Equipped ability
                this.isDashing = false;
                this.isParrying = false;

                this.facingRight = true;
                this.attackBox = null;
                this.attackTimer = 0; // For visual feedback

                // Stats
                this.damageMult = 1;
                this.speedMult = 1;
                this.reachMult = 1;
                this.cooldownMult = 1;
            }
            equipAbility(ability) {
                this.activeAbility = ability;
                game.floatingTexts.push(new FloatingText(this.pos.x, this.pos.y - 40, "ABILITY EQUIPPED!", "#0ff"));
            }
            triggerAbility() {
                if (this.activeAbility && this.activeAbility.canTrigger()) {
                    this.activeAbility.trigger(this);
                }
            }
            update() {
                // Ability Updates
                if (this.activeAbility) this.activeAbility.update(this);

                // If Dashing, physics are overridden by ability
                if (this.isDashing) {
                    this.pos.x += this.vel.x;
                    // No gravity, no collision check for walls? Maybe walls stop dash?
                    // For now, let's allow ghosting through enemies but walls stop
                    this.checkCollisions(true); // Wall stop
                    return;
                }

                // If Parrying, rooted
                if (this.isParrying) return;

                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.invulnerable > 0) this.invulnerable--;
                if (this.attackTimer > 0) this.attackTimer--;

                // Movement Input
                let move = 0;
                if (keys['ArrowRight'] || keys['d']) move = 1;
                if (keys['ArrowLeft'] || keys['a']) move = -1;

                this.vel.x = move * this.speed * this.speedMult;
                if (move !== 0) this.facingRight = move > 0;

                // Jump
                if ((keys['ArrowUp'] || keys['w'] || keys[' ']) && this.grounded) {
                    this.vel.y = this.jumpForce;
                    this.grounded = false;
                    SoundManager.playJump();
                    // Dust particles
                    for (let i = 0; i < 5; i++) game.particles.push(new Particle(this.pos.x + 20, this.pos.y + 60, '#888', 2, 4, 20));
                }

                super.update();

                // Check Pit Death
                if (this.pos.y > 1000) {
                    this.takeDamage(999);
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);
                if (!this.facingRight) ctx.scale(-1, 1);

                // Visual override for Ability actions
                if (this.isDashing) {
                    ctx.globalAlpha = 0.5;
                    ctx.scale(1.2, 0.8); // Stretch
                }

                // Draw Skin
                let skin = game.skin;

                // Body
                ctx.fillStyle = (this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) ? '#f00' : skin.data.body;
                // Parry Color Override
                if (this.isParrying) ctx.fillStyle = '#fff';

                ctx.fillRect(-20, -30, 40, 60);

                // Parry Shield Visual
                if (this.isParrying) {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(15, 0, 30, -Math.PI / 4, Math.PI / 4); ctx.stroke();
                }

                // ... (Rest of drawing is mostly same, just ensuring context restored)

                // Head
                ctx.fillStyle = skin.data.head;
                ctx.fillRect(-15, -50, 30, 20); // Head above body

                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(5, -45, 5, 5); // Eye

                // Weapon
                if (this.attackTimer > 0) {
                    // ... stored in simple update
                } else {
                    // Sword at side
                    ctx.fillStyle = skin.data.weapon;
                    ctx.fillRect(10, -10, 5, 30);
                }

                // Legs
                if (Math.abs(this.vel.x) > 0.1 && this.grounded) {
                    let legFactor = Math.sin(Date.now() / 50) * 10;
                    ctx.strokeStyle = '#111';
                    ctx.beginPath(); ctx.moveTo(-5, 20); ctx.lineTo(-8 - legFactor, 40); ctx.stroke(); // Back leg
                    ctx.beginPath(); ctx.moveTo(5, 20); ctx.lineTo(8 + legFactor, 40); ctx.stroke(); // Front leg
                } else if (!this.grounded) {
                    ctx.strokeStyle = '#111';
                    ctx.beginPath(); ctx.moveTo(-5, 20); ctx.lineTo(-10, 35); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(5, 20); ctx.lineTo(10, 30); ctx.stroke();
                }

                // Sword Slash
                if (this.attackTimer > 0) {
                    let p = 1 - (this.attackTimer / 10); // Hardcoded duration from attack method
                    ctx.strokeStyle = COLORS.slash;
                    ctx.lineWidth = 4 - (p * 3);
                    ctx.beginPath();
                    ctx.arc(10, -10, 50 + (game.player.reachMult > 1 ? 20 : 0), -Math.PI / 2 + (p * Math.PI), -Math.PI / 2 + (p * Math.PI) + Math.PI / 3);
                    ctx.stroke();
                }

                ctx.restore();
            }
            takeDamage(amount) {
                if (this.invulnerable > 0 || this.isDashing) return;

                if (this.isParrying) {
                    // Parry Success!
                    SoundManager.playTone(1200, 'sine', 0.2, 0.2); // Ding!
                    game.floatingTexts.push(new FloatingText(this.pos.x, this.pos.y - 40, "PARRY!", "#0ff"));
                    this.invulnerable = 30; // Brief invu

                    // Stun all enemies on screen? Or just source?
                    // Simplified: Stun all visible enemies
                    game.enemies.forEach(e => {
                        if (Math.abs(e.pos.x - this.pos.x) < 400 && Math.abs(e.pos.y - this.pos.y) < 200) {
                            e.takeHit(0, this.pos.x < e.pos.x); // Trigger stun with 0 dmg
                        }
                    });
                    return;
                }

                this.health -= amount;
                this.invulnerable = 60;
                SoundManager.playHit();
                game.shakeScreen(10);

                if (this.health <= 0) {
                    game.gameOver();
                }
            }
            attack() {
                if (this.attackCooldown > 0 || this.isParrying || this.isDashing) return;

                this.attackCooldown = Math.floor(25 * this.cooldownMult); // Base 25 frames
                this.attackTimer = 10;
                SoundManager.playTone(200 + Math.random() * 50, 'square', 0.1, 0.05); // Slash sound

                // Hitbox
                let range = 60 * this.reachMult;
                let damage = 1 * this.damageMult;

                // Center of attack box based on facing
                let cx = this.pos.x + this.w / 2 + (this.facingRight ? 30 : -30);
                let cy = this.pos.y + this.h / 2;

                this.attackBox = new Box(cx - range / 2, cy - 30, range, 60);

                // Debug draw handled implicitly? logic only below

                // Check Enemies
                if (game.enemies) {
                    game.enemies.forEach(e => {
                        if (this.attackBox.overlaps(e)) {
                            e.takeHit(damage, this.facingRight);
                            // Mana/Rage gain? 
                            game.xp += 10; // Combat XP
                        }
                    });
                }
            }
        }

        class Projectile extends Box {
            constructor(x, y, vx, vy, owner) {
                super(x, y, 15, 15);
                this.vel = new Vector2(vx, vy);
                this.owner = owner;
                this.life = 120;
                this.markedForDeletion = false;
            }
            update() {
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                this.life--;

                if (this.life <= 0) this.markedForDeletion = true;

                // Ground Collision
                if (game.level) {
                    for (let plat of game.level.platforms) {
                        if (this.overlaps(plat)) {
                            this.markedForDeletion = true;
                            // Poof effect
                            for (let i = 0; i < 3; i++) game.particles.push(new Particle(this.pos.x + 7, this.pos.y + 7, COLORS.mageProjectile, 2, 3, 10));
                        }
                    }
                }

                // Player Collision
                if (this.owner !== 'PLAYER' && this.overlaps(game.player)) {
                    game.player.takeDamage(1);
                    this.markedForDeletion = true;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x + 7, this.pos.y + 7);
                ctx.rotate(Date.now() / 50);
                ctx.fillStyle = COLORS.mageProjectile;
                ctx.fillRect(-6, -6, 12, 12);
                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, w, h, color) {
                super(x, y, w, h);
                this.color = color;
                this.dead = false;
                this.hp = 1;
                this.state = ENEMY_STATE.IDLE;
                this.stateTimer = 0;
                this.facingRight = true;
                this.alertRange = 350;
                this.attackRange = 40;
                this.isElite = false;
            }
            makeElite() {
                this.isElite = true;
                this.hp *= 2;
                this.w *= 1.2;
                this.h *= 1.2;
                this.speed *= 1.4;
            }
            changeState(newState) {
                this.state = newState;
                this.stateTimer = 0;
            }
            takeHit(damage, fromRight) {
                // Base behavior, can be overridden
                this.hp -= damage;
                SoundManager.playEnemyHit();

                // Stun Logic
                this.stunned = 15; // 15 frames stun
                this.changeState(ENEMY_STATE.STUNNED);

                // Knockback
                this.vel.x = fromRight ? -5 : 5;
                this.vel.y = -3;

                if (this.hp <= 0) {
                    this.die();
                    return true;
                }
                return false;
            }
            die() {
                if (this.dead) return;
                this.dead = true;
                this.markedForDeletion = true;
                for (let i = 0; i < 15; i++) {
                    game.particles.push(new Particle(this.pos.x + this.w / 2, this.pos.y + this.h / 2, this.color, 4, 6, 30));
                    game.particles.push(new Particle(this.pos.x + this.w / 2, this.pos.y + this.h / 2, '#fff', 6, 3, 10)); // Spark
                }
            }
            update() {
                super.update();
                this.stateTimer++;
                // Generic check for fall
                if (this.pos.y > 1000) this.markedForDeletion = true;

                if (this.state === ENEMY_STATE.STUNNED) {
                    this.pos.x += this.vel.x; // Apply knockback velocity
                    this.vel.x *= 0.8; // Friction
                    if (this.stateTimer > 15) {
                        this.changeState(ENEMY_STATE.IDLE);
                    }
                    return;
                }
            }

            hasGroundAhead() {
                // Rely on velocity first, fallback to facingRight
                let dir = 0;
                if (Math.abs(this.vel.x) > 0.1) dir = Math.sign(this.vel.x);
                else dir = this.facingRight ? 1 : -1;

                let checkX = this.pos.x + this.w / 2 + (dir * (this.w / 2 + 20)); // Check slightly ahead of center (was 10, increased to 20)
                let checkY = this.pos.y + this.h + 10; // Slightly deeper check

                // Check static platforms
                for (let p of game.level.platforms) {
                    // Optimization: Skip if far away X (150px range check is plenty)
                    if (checkX + 150 < p.pos.x || checkX - 150 > p.pos.x + p.w) continue;

                    if (checkX > p.pos.x && checkX < p.pos.x + p.w &&
                        checkY > p.pos.y && checkY < p.pos.y + p.h + 10) {
                        return true;
                    }
                }

                // Check Moving Platforms
                for (let mp of game.level.movingPlatforms) {
                    if (checkX > mp.pos.x && checkX < mp.pos.x + mp.w &&
                        checkY > mp.pos.y && checkY < mp.pos.y + mp.h + 10) {
                        return true;
                    }
                }
                return false;
            }
        }

        class Ghoul extends Enemy {
            constructor(x, y) {
                super(x, y, 40, 40, COLORS.ghoulBody);
                this.hp = 3 + Math.floor(game.levelIndex * 0.2); // Base 3 (2 hits)
                this.speed = 1.5 + (game.levelIndex * 0.1);
                this.dir = 1;
            }
            update() {
                if (this.dead) return;
                super.update();

                let dist = game.player.pos.x - this.pos.x;
                let heightDiff = Math.abs(game.player.pos.y - this.pos.y);

                // Simple AI logic
                if (this.state === ENEMY_STATE.IDLE) {
                    this.vel.x = this.dir * this.speed;
                    this.facingRight = this.dir > 0; // Ensure facing matches movement

                    if (Math.abs(dist) < this.alertRange && heightDiff < 100) {
                        this.changeState(ENEMY_STATE.CHASE);
                    }
                    // Patrol turn around
                    if (this.grounded) {
                        // Use hasGroundAhead instead of manual check
                        if (!this.hasGroundAhead()) {
                            this.dir *= -1;
                            this.vel.x *= -1;
                        }
                    }
                } else if (this.state === ENEMY_STATE.CHASE) {
                    this.facingRight = dist > 0;
                    this.vel.x = Math.sign(dist) * (this.speed * 1.8);

                    // Ledge Detection in Chase
                    if (this.grounded && !this.hasGroundAhead()) {
                        this.vel.x = 0;
                        // Wait at edge briefly? Or just stop chase?
                        // Let's just stop moving for this frame to avoid fall
                    }

                    if (Math.abs(dist) > this.alertRange * 1.5) this.changeState(ENEMY_STATE.IDLE);
                }
            }
            draw(ctx) {
                if (this.dead) return;
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);
                if (this.vel.x < 0) ctx.scale(-1, 1);

                // Glow if Elite
                if (this.isElite) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = COLORS.eliteGlow;
                } else {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLORS.ghoulGlow;
                }

                // Body (Jagged)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(-15, 20);
                ctx.lineTo(-24, -12); // Spikier
                ctx.lineTo(0, -18);
                ctx.lineTo(24, -8); // Hunchback
                ctx.lineTo(15, 20);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Eyes (Glowing)
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(8, -5, 3, 0, Math.PI * 2); ctx.fill();

                // Mouth
                if (this.state === ENEMY_STATE.CHASE) {
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.moveTo(5, 5); ctx.lineTo(15, 10); ctx.lineTo(5, 15); ctx.fill();
                }
                ctx.restore();
            }
        }

        class ShieldGoblin extends Enemy {
            constructor(x, y) {
                super(x, y, 45, 45, '#464');
                this.hp = 4 + Math.floor(game.levelIndex * 0.4); // Base 4 (Tanky)
                this.speed = 0.8;
                this.shieldUp = true;
            }
            takeHit(damage, fromRight) { // fromRight = is damage coming from Right side?
                // Logic: if facing Right and hit from Right -> BLOCK
                // Logic: if facing Left and hit from Left -> BLOCK
                // Actually passed arg from player is slightly different usually. 
                // Let's rely on position check inside logic or pass source X

                // Re-calculating direction context locally to be sure
                let hitFromFront = (this.facingRight && fromRight) || (!this.facingRight && !fromRight);

                if (hitFromFront) {
                    game.floatingTexts.push(new FloatingText(this.pos.x + this.w / 2, this.pos.y, "BLOCKED", "#fff"));
                    SoundManager.playTone(80, 'square', 0.05, 0.1); // Metalsound
                    // Slight knockback
                    this.vel.x = this.facingRight ? -2 : 2;
                    return false;
                }
                return super.takeHit(damage);
            }
            update() {
                if (this.dead) return;
                super.update();
                let dist = game.player.pos.x - this.pos.x;
                this.facingRight = this.vel.x > 0;

                if (Math.abs(dist) < this.alertRange) {
                    // Always face player when close
                    this.facingRight = dist > 0;
                    this.vel.x = (dist > 0 ? 1 : -1) * this.speed;
                } else {
                    this.vel.x = 0;
                }

                // Ledge Detection (Stop at edge)
                if (this.grounded && !this.hasGroundAhead()) {
                    this.vel.x = 0;
                }
            }
            draw(ctx) {
                if (this.dead) return;
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);
                if (!this.facingRight) ctx.scale(-1, 1);

                // Body
                ctx.fillStyle = '#464';
                ctx.fillRect(-15, -20, 30, 40);

                // Shield
                ctx.fillStyle = COLORS.shield;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(10, -15, 10, 35);
                ctx.fill(); ctx.stroke();

                // Eyes
                ctx.fillStyle = '#faa';
                ctx.beginPath(); ctx.arc(-5, -10, 2, 0, Math.PI * 2); ctx.fill();

                ctx.restore();
            }
        }

        class Mage extends Enemy {
            constructor(x, y) {
                super(x, y, 35, 55, COLORS.mageBody);
                this.hp = 3 + Math.floor(game.levelIndex * 0.3); // Base 3 (Standard)
                this.speed = 1.2;
                this.cooldown = 100;
            }
            update() {
                if (this.dead) return;
                super.update();
                let dist = game.player.pos.x - this.pos.x;
                let absDist = Math.abs(dist);

                this.facingRight = dist > 0;

                if (absDist < 200) {
                    // Retreat
                    this.changeState(ENEMY_STATE.RETREAT);
                    this.vel.x = (dist > 0 ? -1 : 1) * this.speed;
                } else if (absDist < 500 && this.cooldown <= 0) {
                    // Attack
                    this.changeState(ENEMY_STATE.ATTACK);
                    this.vel.x = 0;
                    this.cooldown = 180 + Math.random() * 60;
                    this.stateTimer = 40; // Windup
                } else {
                    this.vel.x = 0;
                    this.changeState(ENEMY_STATE.IDLE);
                }

                if (this.state === ENEMY_STATE.ATTACK) {
                    if (this.stateTimer === 10) {
                        // Shoot
                        let dir = this.facingRight ? 1 : -1;
                        game.projectiles.push(new Projectile(this.pos.x + (dir * 20), this.pos.y, dir * 5, 0, 'ENEMY'));
                        SoundManager.playTone(400, 'sine', 0.2, 0.1);
                    }
                }
                if (this.cooldown > 0) this.cooldown--;
            }
            draw(ctx) {
                if (this.dead) return;
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);
                if (!this.facingRight) ctx.scale(-1, 1);

                // Robe
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(-15, 25);
                ctx.lineTo(15, 25);
                ctx.fill();

                // Hat
                ctx.fillStyle = '#306';
                ctx.beginPath();
                ctx.moveTo(-20, -20);
                ctx.lineTo(20, -20);
                ctx.lineTo(0, -50);
                ctx.fill();

                // Windup Effect
                if (this.state === ENEMY_STATE.ATTACK && this.stateTimer > 10) {
                    ctx.fillStyle = COLORS.mageProjectile;
                    ctx.beginPath();
                    ctx.arc(20, -5, Math.random() * 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Kamikaze extends Enemy {
            constructor(x, y) {
                super(x, y, 30, 30, COLORS.kamikazeBody);
                this.hp = 2 + Math.floor(game.levelIndex * 0.2); // Base 2, scales very slowly
                this.speed = 3.5;
                this.exploded = false;
            }
            update() {
                if (this.dead) return;
                super.update();
                let dist = game.player.pos.x - this.pos.x;
                let absDist = Math.abs(dist);

                if (!this.exploded && absDist < 400 && Math.abs(game.player.pos.y - this.pos.y) < 100) {
                    this.changeState(ENEMY_STATE.CHASE);
                }

                if (this.state === ENEMY_STATE.CHASE) {
                    this.vel.x = Math.sign(dist) * this.speed;
                    // Jump small obstacles OR at ledge
                    let atLedge = this.grounded && !this.hasGroundAhead();
                    if ((this.vel.x !== 0 && this.grounded && Math.random() < 0.05) || atLedge) {
                        this.vel.y = -8;
                        // If at ledge and jumping doesn't help (still no ground), maybe reverse? 
                        // But for Kamikaze, jumping blindly is fine.
                    }

                    if (absDist < 40) {
                        this.changeState(ENEMY_STATE.ATTACK);
                        this.vel.x = 0;
                        this.stateTimer = 40; // Fuse
                    }
                }

                if (this.state === ENEMY_STATE.ATTACK) {
                    if (this.stateTimer <= 0) {
                        this.explode();
                    }
                    // Sound pitch up
                    if (this.stateTimer % 10 === 0) SoundManager.playTone(200 + (40 - this.stateTimer) * 10, 'sawtooth', 0.05, 0.05);
                }
            }
            explode() {
                this.dead = true;
                this.markedForDeletion = true;
                this.exploded = true;
                game.shakeScreen(20);
                SoundManager.playKill(); // Boom
                // Area Damage
                let blastRadius = 120;
                let dx = game.player.pos.x - this.pos.x;
                let dy = game.player.pos.y - this.pos.y;
                let d = Math.sqrt(dx * dx + dy * dy);
                if (d < blastRadius) {
                    game.player.takeDamage(2);
                    game.player.vel.x = Math.sign(dx) * 15;
                    game.player.vel.y = -10;
                }
                // Visuals
                for (let i = 0; i < 30; i++) {
                    game.particles.push(new Particle(this.pos.x, this.pos.y, COLORS.kamikazeFlash, 5, 5, 40));
                }
            }
            draw(ctx) {
                if (this.dead) return;
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);

                if (this.state === ENEMY_STATE.ATTACK) {
                    let shake = Math.random() * 4 - 2;
                    ctx.translate(shake, shake);
                    if (Math.floor(Date.now() / 50) % 2 === 0) ctx.fillStyle = '#fff';
                    else ctx.fillStyle = COLORS.kamikazeBody;
                } else {
                    ctx.fillStyle = COLORS.kamikazeBody;
                }

                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();

                // Face
                ctx.fillStyle = '#000';
                ctx.fillRect(-5, -5, 10, 4); // Eyes
                ctx.fillRect(-3, 5, 6, 6); // Mouth screaming

                ctx.restore();
            }
        }

        class Bat extends Enemy {
            constructor(x, y) {
                super(x, y, 35, 25, COLORS.batBody);
                this.baseY = y;
                this.angle = Math.random() * Math.PI;
                this.swooping = false;
                this.targetPos = new Vector2(0, 0);
            }
            update() {
                if (this.dead) return;

                let distToPlayer = Math.sqrt(Math.pow(game.player.pos.x - this.pos.x, 2) + Math.pow(game.player.pos.y - this.pos.y, 2));

                if (!this.swooping) {
                    // Idle flying
                    this.angle += 0.05;
                    this.pos.y = this.baseY + Math.sin(this.angle) * 30;
                    this.pos.x += Math.sin(this.angle * 0.5) * 2;

                    // Trigger Swoop
                    if (distToPlayer < 250 && game.player.pos.y > this.pos.y && Math.random() < 0.02) {
                        this.swooping = true;
                        this.targetPos = new Vector2(game.player.pos.x, game.player.pos.y);
                        this.vel = new Vector2((this.targetPos.x - this.pos.x) * 0.04, (this.targetPos.y - this.pos.y) * 0.04);
                    }
                } else {
                    // Swooping
                    this.pos.x += this.vel.x;
                    this.pos.y += this.vel.y;

                    if (this.pos.y > this.targetPos.y + 100 || this.grounded || this.pos.y > 900) {
                        this.swooping = false; // Return to hover logic (simplified: just slowly float up)
                        this.vel.y = -2;
                    }
                }

                // Return to base height slowly if not swooping
                if (!this.swooping && Math.abs(this.pos.y - this.baseY) > 50) {
                    this.pos.y += (this.baseY - this.pos.y) * 0.02;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x + this.w / 2, this.pos.y + this.h / 2);

                // Flap animation
                let flap = Math.sin(Date.now() / 50) * 15;

                ctx.fillStyle = COLORS.batWing;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.lineTo(-25, -10 + flap); // Left wing tip
                ctx.lineTo(-10, 5);
                ctx.lineTo(0, 5);
                ctx.lineTo(10, 5);
                ctx.lineTo(25, -10 + flap); // Right wing tip
                ctx.lineTo(0, 5);
                ctx.fill();

                ctx.fillStyle = COLORS.batBody;
                ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = '#f00'; // Eyes
                ctx.fillRect(-3, -2, 2, 2); ctx.fillRect(3, -2, 2, 2);

                ctx.restore();
            }
        }

        // --- Procedural Generation ---

        class Level {
            constructor(platforms, spikes, enemies, portalPos, biome, traps, objectives) {
                this.platforms = platforms;
                this.spikes = spikes;
                this.enemies = enemies; // Live array
                this.portal = new Box(portalPos.x, portalPos.y, 50, 80);
                this.biome = biome;
                this.movingPlatforms = [];
                this.crumblingPlatforms = [];
                this.traps = traps || [];
                this.objectives = objectives || [];
            }
        }

        const DIFFICULTY_TIERS = {
            TIER_1: { // Levels 0-1 (Tutorial)
                allowedEnemies: ['GHOUL'],
                trapChance: 0.0,
                eliteChance: 0.0,
                maxChunkComplexity: 1, // Only Flat or simple Gaps
                recoveryChance: 1.0 // Guaranteed heal
            },
            TIER_2: { // Levels 2-3 (Intermediate)
                allowedEnemies: ['GHOUL', 'BAT'],
                trapChance: 0.15,
                eliteChance: 0.05,
                maxChunkComplexity: 3, // Steps, Spikes
                recoveryChance: 0.8
            },
            TIER_3: { // Levels 4-6 (Advanced)
                allowedEnemies: ['GHOUL', 'BAT', 'SHIELD', 'MAGE'],
                trapChance: 0.25,
                eliteChance: 0.1,
                maxChunkComplexity: 5, // Floating, Moving
                recoveryChance: 0.5
            },
            TIER_4: { // Levels 7+ (Mastery)
                allowedEnemies: ['GHOUL', 'BAT', 'SHIELD', 'MAGE', 'KAMIKAZE'],
                trapChance: 0.4,
                eliteChance: 0.2, // Very high elite chance
                maxChunkComplexity: 5,
                recoveryChance: 0.2
            }
        };

        class LevelGenerator {

            static getBiome(levelIndex) {
                if (levelIndex < 2) return BIOME_DATA.DUNGEON;
                if (levelIndex < 4) return BIOME_DATA.LAVA;
                if (levelIndex < 6) return BIOME_DATA.ICE;
                return BIOME_DATA.VOID;
            }

            // Chunks are functions that return objects relative to an offset X, Y
            static generate(levelNum) {
                let chunksCount = 4 + Math.floor(levelNum * 0.8); // Level 1=4 chunks, Level 5=8 chunks
                if (chunksCount > 20) chunksCount = 20; // Cap length

                let biome = LevelGenerator.getBiome(levelNum);

                // Determine Difficulty Tier
                let tier = DIFFICULTY_TIERS.TIER_1;
                if (levelNum >= 7) tier = DIFFICULTY_TIERS.TIER_4;
                else if (levelNum >= 4) tier = DIFFICULTY_TIERS.TIER_3;
                else if (levelNum >= 2) tier = DIFFICULTY_TIERS.TIER_2;

                let platforms = [];
                let spikes = [];
                let enemies = [];
                let movingPlats = [];
                let crumblePlats = [];
                let traps = [];
                let objectives = [];

                let currentX = 0;
                let currentY = 500; // Start height

                // Start Chunk
                platforms.push(new Box(currentX, currentY, 400, 50));
                currentX += 400;

                for (let i = 0; i < chunksCount; i++) {
                    // Select Chunk Type based on Tier Complexity
                    // Increase complexity for objectives
                    let maxType = tier.maxChunkComplexity;
                    if (levelNum >= 3) maxType = 7; // Allow Arena from Lvl 3

                    // Define helpers inside loop or pass RNG/Tier? 
                    // Better to define them here to access 'tier' and 'rng' and 'enemies' array.

                    const spawnEnemy = (x, y) => {
                        let type = rng.pick(tier.allowedEnemies);
                        let e = null;
                        if (type === 'GHOUL') e = new Ghoul(x, y);
                        else if (type === 'BAT') e = new Bat(x, y);
                        else if (type === 'SHIELD') e = new ShieldGoblin(x, y);
                        else if (type === 'MAGE') e = new Mage(x, y);
                        else if (type === 'KAMIKAZE') e = new Kamikaze(x, y);

                        if (e) {
                            // Elite Chance
                            if (rng.next() < tier.eliteChance) e.makeElite();
                            enemies.push(e);
                        }
                    };

                    const spawnEncounter = (type, x, y, width) => {
                        switch (type) {
                            case 'PHALANX': // Shield acts as Wall for Mage
                                let s = new ShieldGoblin(x + width / 2 - 50, y);
                                game.enemies.push(s); enemies.push(s); // Wait, we push to 'enemies' array which is passed to Level. 
                                // Game.startLevel sets game.enemies = level.enemies. So just push to 'enemies'.
                                // Using 'enemies' array defined in generate
                                enemies.push(s);
                                enemies.push(new Mage(x + width / 2 + 100, y));
                                break;
                            case 'AMBUSH': // Aerial enemies over hazards
                                enemies.push(new Bat(x + 50, y - 100));
                                enemies.push(new Bat(x + width - 50, y - 130));
                                break;
                            case 'BREACH': // Aggro rush + Heavy hitter
                                enemies.push(new Kamikaze(x + 50, y));
                                enemies.push(new EliteGhoul(x + width - 50, y));
                                break;
                            default: // Fallback random (using tier allowed)
                                if (rng.next() < 0.6) {
                                    spawnEnemy(x + width / 2, y);
                                }
                        }
                    };

                    let chunkType = Math.floor(rng.next() * (maxType + 1));

                    // Force easier chunks for first level/first chunk
                    if (levelNum === 0 && i === 0) chunkType = 0;

                    let chunkWidth = 0;

                    switch (chunkType) {
                        case 0: // Flat
                            chunkWidth = 400;
                            platforms.push(new Box(currentX, currentY, 400, 50));

                            // Encounter: Phalanx (Tier 2+) or Breach (Tier 3+)
                            if (levelNum >= 2 && rng.next() < 0.4) {
                                spawnEncounter('PHALANX', currentX + 50, currentY - 50, 300);
                            } else if (levelNum >= 5 && rng.next() < 0.3) {
                                spawnEncounter('BREACH', currentX + 50, currentY - 50, 300);
                            } else {
                                // Random Enemy
                                if (rng.next() < 0.6) {
                                    spawnEnemy(currentX + 200, currentY - 50);
                                }
                            }
                            break;

                        case 1: // Gap (Jump)
                            chunkWidth = 200;
                            platforms.push(new Box(currentX, currentY, 50, 50)); // Start lip
                            platforms.push(new Box(currentX + 150, currentY, 50, 50)); // End lip
                            // Maybe a bat?
                            if (levelNum >= 1 && rng.next() < 0.3) enemies.push(new Bat(currentX + 100, currentY - 100));
                            break;

                        case 2: // Step Up
                            chunkWidth = 300;
                            platforms.push(new Box(currentX, currentY, 150, 50));
                            currentY -= 100; // Go Up
                            platforms.push(new Box(currentX + 150, currentY, 150, 50));
                            spawnEncounter('RANDOM', currentX + 150, currentY - 50, 150);
                            break;

                        case 3: // Step Down
                            chunkWidth = 300;
                            platforms.push(new Box(currentX, currentY, 150, 50));
                            currentY += 100; // Go Down
                            platforms.push(new Box(currentX + 150, currentY, 150, 50));
                            spawnEncounter('RANDOM', currentX + 150, currentY - 50, 150);
                            break;

                        case 4: // Spike Pit
                            chunkWidth = 500;
                            platforms.push(new Box(currentX, currentY, 50, 50)); // Start
                            // Spikes
                            spikes.push(new Box(currentX + 50, currentY + 50, 400, 20)); // Threat
                            platforms.push(new Box(currentX + 450, currentY, 50, 50)); // End

                            // Encounter: Ambush (Tier 2+)
                            if (levelNum >= 2 && rng.next() < 0.5) {
                                spawnEncounter('AMBUSH', currentX + 50, currentY, 400);
                            }
                            break;

                        case 5: // Moving Platform
                            chunkWidth = 400;
                            platforms.push(new Box(currentX, currentY, 80, 50)); // Start
                            let mPlat = new MovingPlatform(currentX + 100, currentY, 100, 20, 0, 100, 0.05);
                            if (rng.next() > 0.5) mPlat = new MovingPlatform(currentX + 100, currentY, 100, 20, 150, 0, 0.03);
                            movingPlats.push(mPlat);
                            platforms.push(new Box(currentX + 320, currentY, 80, 50)); // End
                            break;

                        case 6: // Challenge Room (Kill Objective)
                            chunkWidth = 600;
                            // Arena Style
                            platforms.push(new Box(currentX, currentY, 600, 50)); // Floor
                            platforms.push(new Box(currentX, currentY - 200, 20, 200)); // Wall Left
                            platforms.push(new Box(currentX + 580, currentY - 200, 20, 200)); // Wall Right

                            platforms.push(new Box(currentX + 100, currentY - 80, 100, 20));
                            platforms.push(new Box(currentX + 400, currentY - 80, 100, 20));

                            let obj = new KillChallenge(currentX + 50, currentY - 200, 500, 200, 3);

                            for (let k = 0; k < 3; k++) {
                                let eX = currentX + 100 + rng.next() * 400;
                                let eY = currentY - 100;
                                let type = rng.pick(tier.allowedEnemies);
                                let enemy = null;

                                // Manual instantiation for simplicity in this loop
                                if (type === 'GHOUL') enemy = new Ghoul(eX, eY);
                                else if (type === 'BAT') enemy = new Bat(eX, eY);
                                else if (type === 'SHIELD') enemy = new ShieldGoblin(eX, eY);
                                else if (type === 'MAGE') enemy = new Mage(eX, eY);
                                else if (type === 'KAMIKAZE') enemy = new Kamikaze(eX, eY);

                                if (enemy) obj.enemiesToSpawn.push(enemy);
                            }
                            objectives.push(obj);
                            break;

                        case 7: // Arena Gauntlet
                            chunkWidth = 800;
                            platforms.push(new Box(currentX, currentY, 800, 50));
                            platforms.push(new Box(currentX, currentY - 300, 800, 50));
                            platforms.push(new Box(currentX, currentY - 300, 50, 300));
                            platforms.push(new Box(currentX + 750, currentY - 300, 50, 300));

                            let gateL = new ArenaGate(currentX + 60, currentY - 200, 200);
                            let gateR = new ArenaGate(currentX + 720, currentY - 200, 200);

                            let arena = new ArenaController(currentX + 100, currentY - 200, 600, 200);
                            arena.gates = [gateL, gateR];

                            let diff = Math.floor(levelNum / 2) + 1;

                            // Wave 1: Fodder
                            let w1 = [];
                            for (let k = 0; k < 2 + diff; k++) w1.push(Ghoul);
                            arena.addWave(w1);

                            // Wave 2: Mix
                            if (levelNum >= 2) {
                                let w2 = [];
                                w2.push(ShieldGoblin);
                                w2.push(Mage);
                                w2.push(Bat);
                                arena.addWave(w2);
                            }

                            // Wave 3: Elite
                            if (levelNum >= 4) {
                                let w3 = [];
                                w3.push(EliteGhoul);
                                arena.addWave(w3);
                            }
                            objectives.push(arena);
                            break;
                    }

                    // Traps (15% chance independent of encounter?)
                    if (rng.next() < tier.trapChance && levelNum > 0 && chunkType !== 6 && chunkType !== 7) {
                        if (biome === BIOME_DATA.VOID) {
                            traps.push(new LaserTrap(currentX + chunkWidth / 2, currentY - 100, 150, rng.next() > 0.5));
                        } else {
                            if (rng.next() > 0.5) traps.push(new BladeTrap(currentX + chunkWidth / 2 - 20, currentY));
                            else traps.push(new PressurePlateTrap(currentX + chunkWidth / 2 - 15, currentY - 20));
                        }
                    }

                    currentX += chunkWidth;
                }

                // End Chunk
                platforms.push(new Box(currentX + 50, currentY, 300, 50));
                let portalPos = new Vector2(currentX + 200, currentY - 80);

                let level = new Level(platforms, spikes, enemies, portalPos, biome, traps);
                level.movingPlatforms = movingPlats;
                level.crumblingPlatforms = crumblePlats;
                level.objectives = objectives;
                return level;
            }
        }

        // --- Game Manager ---
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.state = 'START';
                this.score = 0;
                this.levelIndex = 0;
                this.camera = new Vector2(0, 0);
                this.shake = 0;
                this.triggerRestart = false;

                // Persistence
                this.saveData = SaveManager.load();
                this.skin = SKINS[this.saveData.currentSkin] || SKINS.DEFAULT;

                this.freezeFrames = 0;
                this.floatingTexts = [];
                this.projectiles = [];
                this.objects = []; // For Chests, Items, etc.

                // Progression
                this.xp = 0;
                this.level = 1;
                this.nextLevelXp = 500;
                this.availableUpgrades = [];

                // Roguelike Modes
                this.seed = Date.now();
                this.gameMode = 'STANDARD'; // STANDARD, DAILY, ENDLESS
                this.modifiers = {
                    oneHeart: false,
                    doubleEnemies: false,
                    noHealing: false,
                    endless: false
                };

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            setMode(mode) {
                this.gameMode = mode;
                this.modifiers = {
                    oneHeart: false,
                    doubleEnemies: false,
                    noHealing: false,
                    endless: false
                };

                if (mode === 'DAILY') {
                    // Seed based on Day
                    let d = new Date();
                    this.seed = parseInt(`${d.getFullYear()}${d.getMonth() + 1}${d.getDate()}`);
                    // Random modifiers based on seed?
                    let dailyRng = new SeededRandom(this.seed);
                    if (dailyRng.next() > 0.5) this.modifiers.doubleEnemies = true;
                    if (dailyRng.next() > 0.7) this.modifiers.noHealing = true;
                } else if (mode === 'ENDLESS') {
                    this.modifiers.endless = true;
                    this.seed = Date.now();
                } else {
                    this.seed = Date.now();
                }
            }

            addXp(amount) {
                this.xp += amount;
                if (this.xp >= this.nextLevelXp) {
                    this.xp -= this.nextLevelXp;
                    this.level++;
                    this.nextLevelXp = Math.floor(this.nextLevelXp * 1.5);
                    this.triggerLevelUp();
                }
            }

            triggerLevelUp() {
                this.state = 'LEVEL_UP';
                // Pick 3 random upgrades
                this.availableUpgrades = [];
                let pool = [...UPGRADES];

                // Allow Ability Upgrades
                pool.push({ id: 'UNLOCK_DASH', name: 'Dash Ability', description: 'Unlock Dash (SHIFT)', icon: '>>', type: 'ACTIVE' });
                pool.push({ id: 'UNLOCK_PARRY', name: 'Parry Ability', description: 'Unlock Parry (SHIFT)', icon: 'P', type: 'ACTIVE' });

                // Filter out already equipped
                if (this.player.activeAbility && this.player.activeAbility.name === 'Dash') pool = pool.filter(u => u.id !== 'UNLOCK_DASH');
                if (this.player.activeAbility && this.player.activeAbility.name === 'Parry') pool = pool.filter(u => u.id !== 'UNLOCK_PARRY');

                for (let i = 0; i < 3; i++) {
                    if (pool.length === 0) break;
                    let idx = Math.floor(Math.random() * pool.length);
                    this.availableUpgrades.push(pool[idx]);
                    pool.splice(idx, 1);
                }
                SoundManager.playTone(400, 'sine', 0.5, 0.2); // Level Up Sound
            }

            applyUpgrade(upgradeId) {
                switch (upgradeId) {
                    case 'VITALITY':
                        this.player.maxHealth++;
                        if (!this.modifiers.noHealing) this.player.health = this.player.maxHealth;
                        break;
                    case 'STRENGTH':
                        this.player.damageMult = (this.player.damageMult || 1) + 0.5;
                        break;
                    case 'AGILITY':
                        // We need to modify base speed, maybe add a multiplier to Player class
                        this.player.speedMult = (this.player.speedMult || 1) * 1.2;
                        break;
                    case 'REACH':
                        this.player.reachMult = (this.player.reachMult || 1) + 0.3;
                        break;
                    case 'HASTE':
                        this.player.cooldownMult = (this.player.cooldownMult || 1) * 0.8;
                        break;
                    case 'UNLOCK_DASH':
                        this.player.equipAbility(new DashAbility());
                        break;
                    case 'UNLOCK_PARRY':
                        this.player.equipAbility(new ParryAbility());
                        break;
                }
                this.state = 'PLAYING';
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            shakeScreen(amt) { this.shake = amt; }

            startLevel(idx) {
                this.levelIndex = idx;

                // In Endless, we just keep going. But LevelGenerator expects specific index for Tier.
                // We can cap Tier logic or let it stay hard.

                let seedForLevel = this.seed + idx; // Deterministic seed Per Level
                this.level = LevelGenerator.generate(idx, seedForLevel);

                // Apply Biome Colors/Friction
                Object.assign(COLORS, this.level.biome);

                this.enemies = this.level.enemies;

                // Modifier: Double Enemies
                if (this.modifiers.doubleEnemies) {
                    // Duplicate enemies
                    let extra = [];
                    this.enemies.forEach(e => {
                        // Clone logic or just spawn new of same type nearby
                        // Creating new is safer if we knew constructor args easily. 
                        // Let's just spawn a Ghoul for every enemy as "Reinforcement"
                        extra.push(new Ghoul(e.pos.x + 20, e.pos.y));
                    });
                    this.enemies = this.enemies.concat(extra);
                }

                this.player = new Player(100, 300);

                // Keep stats if continuing
                if (this.state === 'PLAYING' && this.playerRef) {
                    this.player.health = this.playerRef.health;
                    this.player.maxHealth = this.playerRef.maxHealth; // Persist Max HP
                    this.player.score = this.score;
                    // Persist Upgrades
                    this.player.damageMult = this.playerRef.damageMult || 1;
                    this.player.speedMult = this.playerRef.speedMult || 1;
                    this.player.reachMult = this.playerRef.reachMult || 1;
                    this.player.cooldownMult = this.playerRef.cooldownMult || 1;
                    // Persist Ability
                    this.player.activeAbility = this.playerRef.activeAbility;
                } else {
                    // New Game start
                    if (this.modifiers.oneHeart) {
                        this.player.maxHealth = 1;
                        this.player.health = 1;
                    }
                }

                this.playerRef = this.player;
                this.particles = [];
                this.projectiles = [];
                this.objects = [];

                // Add Objectives from level
                if (this.level.objectives) {
                    this.level.objectives.forEach(o => this.objects.push(o)); // Treat objectives as objects for update/draw? 
                    // Wait, objectives need to be updated. Game.update loops objects?
                    // Let's assume yes or add specific loop. 
                    // Looking at Game.update, it loops `objects`.
                }

                this.state = 'PLAYING';
            }

            nextLevel() {
                if (this.player.health < this.player.maxHealth) this.player.health++;
                this.score += 500;
                this.startLevel(this.levelIndex + 1);
            }

            gameOver() {
                this.state = 'GAMEOVER';

                // Save Progress
                if (this.score > this.saveData.highScore) this.saveData.highScore = this.score;
                // Accumulate stats (assuming totalKills tracked, adding pseudo count for now if not tracked)
                // For this demo, let's just assume we track kills in a 'kills' property
                // this.saveData.totalKills += this.sessionKills; 

                SaveManager.checkUnlocks(this.saveData);
                SaveManager.save(this.saveData);

                this.triggerRestart = false; // Wait for new tap
            }

            update() {
                if (this.triggerRestart && this.state !== 'PLAYING') {
                    this.score = 0;
                    this.startLevel(0);
                    this.triggerRestart = false;
                    return;
                }

                if (this.state !== 'PLAYING') return;

                if (this.freezeFrames > 0) {
                    this.freezeFrames--;
                    return;
                }

                // updateTouchInputs(); // REMOVED: Using Virtual Buttons now
                this.player.update();
                if (this.floatingTexts) {
                    this.floatingTexts.forEach(t => t.update());
                    this.floatingTexts = this.floatingTexts.filter(t => t.life > 0);
                }
                this.projectiles.forEach(p => p.update());
                this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);
                this.enemies.forEach(e => e.update());
                this.enemies = this.enemies.filter(e => !e.markedForDeletion);
                this.particles.forEach(p => p.update());
                this.particles = this.particles.filter(p => !p.markedForDeletion && p.life > 0);
                if (this.objects) this.objects.forEach(o => o.update());

                // Update Platforms
                if (this.level) {
                    this.level.movingPlatforms.forEach(p => p.update());
                    this.level.crumblingPlatforms.forEach(p => p.update());
                    this.level.traps.forEach(t => {
                        t.update();
                        t.checkCollision(this.player);
                    });
                }

                // Update Objectives
                if (this.level && this.level.objectives) {
                    this.level.objectives.forEach(o => o.update());
                }

                // Camera Logic (Adjusted for Zoom)
                // We want to center the player in the ZOOMED coordinate space
                // Virtual Screen Width = this.canvas.width / CAMERA_ZOOM
                let virtualW = this.canvas.width / CAMERA_ZOOM;
                let virtualH = this.canvas.height / CAMERA_ZOOM;

                let targetX = this.player.pos.x - virtualW * 0.4; // Look slightly ahead? 0.4 centers a bit left
                let targetY = this.player.pos.y - virtualH * 0.6;
                this.camera.x += (targetX - this.camera.x) * 0.1;
                this.camera.y += (targetY - this.camera.y) * 0.1;

                if (this.shake > 0) {
                    this.camera.x += (Math.random() - 0.5) * this.shake;
                    this.camera.y += (Math.random() - 0.5) * this.shake;
                    this.shake *= 0.9;
                    if (this.shake < 1) this.shake = 0;
                }
            }

            draw() {
                // Background
                let gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, COLORS.bgGradient1);
                gradient.addColorStop(1, COLORS.bgGradient2);
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.state === 'START') {
                    this.drawMenu("SHADOW OF THE DUNGEON", "High Score: " + this.saveData.highScore, "TAP TO START");

                    // Skin Prompt
                    this.ctx.fillStyle = '#888';
                    this.ctx.font = '16px Segoe UI';
                    this.ctx.fillText(`Skin: ${this.skin.name} [Press T]`, this.canvas.width / 2, this.canvas.height / 2 + 60);

                    this.drawVignette();
                    return;
                }
                if (this.state === 'GAMEOVER') {
                    this.drawMenu("GAME OVER", "Score: " + this.score, "TAP TO RESTART");
                    this.drawVignette();
                    return;
                }
                if (this.state === 'LEVEL_UP') {
                    this.drawLevelUpMenu();
                    return;
                }

                this.ctx.save();

                // --- APPLY ZOOM ---
                this.ctx.scale(CAMERA_ZOOM, CAMERA_ZOOM);
                this.ctx.translate(-Math.floor(this.camera.x), -Math.floor(this.camera.y));

                // Draw Level
                for (let p of this.level.platforms) {
                    this.ctx.fillStyle = COLORS.platformBody;
                    this.ctx.fillRect(p.pos.x, p.pos.y, p.w, p.h);

                    // Nice top glow
                    let grad = this.ctx.createLinearGradient(p.pos.x, p.pos.y, p.pos.x, p.pos.y + 10);
                    grad.addColorStop(0, COLORS.platformTop);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    this.ctx.fillStyle = grad;
                    this.ctx.fillRect(p.pos.x, p.pos.y, p.w, 10);

                    this.ctx.fillStyle = COLORS.platformTop;
                    this.ctx.fillRect(p.pos.x, p.pos.y, p.w, 2); // Thin sharp line

                    if (p.w > 100) {
                        this.ctx.fillStyle = '#333';
                        this.ctx.fillRect(p.pos.x + 50, p.pos.y + 10, 20, 2);
                        this.ctx.fillRect(p.pos.x + 55, p.pos.y + 12, 2, 5);
                    }
                }

                // Draw Traps
                if (this.level && this.level.traps) {
                    this.level.traps.forEach(t => t.draw(this.ctx));
                }

                // Draw Objects (Chests)
                if (this.objects) this.objects.forEach(o => o.draw(this.ctx));

                // Draw Special Platforms
                this.level.movingPlatforms.forEach(p => p.draw(this.ctx));
                this.level.crumblingPlatforms.forEach(p => p.draw(this.ctx));

                for (let s of this.level.spikes) {
                    this.ctx.fillStyle = COLORS.spike;
                    let cnt = Math.floor(s.w / 20);
                    for (let i = 0; i < cnt; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(s.pos.x + i * 20, s.pos.y + s.h);
                        this.ctx.lineTo(s.pos.x + i * 20 + 10, s.pos.y - 10);
                        this.ctx.lineTo(s.pos.x + i * 20 + 20, s.pos.y + s.h);
                        this.ctx.fill();
                    }
                }

                let p = this.level.portal;
                let grad = this.ctx.createLinearGradient(p.pos.x, p.pos.y, p.pos.x, p.pos.y + p.h);
                grad.addColorStop(0, COLORS.portalOne); grad.addColorStop(1, COLORS.portalTwo);
                this.ctx.fillStyle = grad;
                this.ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 200) * 0.3;
                this.ctx.fillRect(p.pos.x, p.pos.y, p.w, p.h);
                this.ctx.globalAlpha = 1;
                this.ctx.strokeStyle = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(p.pos.x + p.w / 2, p.pos.y + p.h / 2, 20 * Math.abs(Math.sin(Date.now() / 500)), 0, Math.PI * 2);
                this.ctx.stroke();

                this.player.draw(this.ctx);
                this.enemies.forEach(e => e.draw(this.ctx));
                this.projectiles.forEach(p => p.draw(this.ctx));
                this.particles.forEach(pt => pt.draw(this.ctx));
                // Draw Objectives
                if (this.level && this.level.objectives) {
                    this.level.objectives.forEach(o => o.draw(this.ctx));
                }

                if (this.floatingTexts) this.floatingTexts.forEach(t => t.draw(this.ctx));

                this.ctx.restore();

                this.drawVignette();
                this.drawHUD();
            }

            drawLevelUpMenu() {
                // Dim background
                this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 40px Segoe UI';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("LEVEL UP!", this.canvas.width / 2, 100);
                this.ctx.font = '20px Segoe UI';
                this.ctx.fillText("Choose an Upgrade", this.canvas.width / 2, 140);

                let cardW = 200;
                let cardH = 250;
                let gap = 20;
                let totalW = (cardW * 3) + (gap * 2);
                let startX = (this.canvas.width - totalW) / 2;
                let startY = 200;

                this.availableUpgrades.forEach((upg, i) => {
                    let x = startX + i * (cardW + gap);
                    let y = startY;

                    this.ctx.fillStyle = '#222';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.fillRect(x, y, cardW, cardH);
                    this.ctx.strokeRect(x, y, cardW, cardH);

                    this.ctx.fillStyle = '#ff0';
                    this.ctx.font = 'bold 24px Segoe UI';
                    this.ctx.fillText(upg.name, x + cardW / 2, y + 50);

                    this.ctx.fillStyle = '#ccc';
                    this.ctx.font = '16px Segoe UI';
                    this.wrapText(this.ctx, upg.desc, x + cardW / 2, y + 100, cardW - 20, 20);
                });
            }

            // Helper for text wrapping
            wrapText(ctx, text, x, y, maxWidth, lineHeight) {
                let words = text.split(' ');
                let line = '';
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = ctx.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    }
                    else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, y);
            }

            handleLevelUpClick(x, y) {
                let cardW = 200;
                let cardH = 250;
                let gap = 20;
                let totalW = (cardW * 3) + (gap * 2);
                let startX = (this.canvas.width - totalW) / 2;
                let startY = 200;

                for (let i = 0; i < 3; i++) {
                    let cardX = startX + i * (cardW + gap);
                    if (x > cardX && x < cardX + cardW && y > startY && y < startY + cardH) {
                        this.applyUpgrade(this.availableUpgrades[i].id);
                        break;
                    }
                }
            }

            drawVignette() {
                // Vignette Overlay for atmosphere
                let rad = Math.max(this.canvas.width, this.canvas.height) * 0.8;
                let grad = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, rad * 0.4,
                    this.canvas.width / 2, this.canvas.height / 2, rad
                );
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, 'rgba(0,0,0,0.7)');
                this.ctx.fillStyle = grad;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawMenu(title, sub, cta) {
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 50px Segoe UI';
                this.ctx.shadowColor = COLORS.ghoulGlow;
                this.ctx.shadowBlur = 20;
                this.ctx.fillText(title, this.canvas.width / 2, this.canvas.height / 2 - 60);
                this.ctx.shadowBlur = 0;
                this.ctx.font = '30px Segoe UI';
                this.ctx.fillText(sub, this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.fillStyle = '#fdb';
                this.ctx.font = 'bold 24px Segoe UI';
                // Pulse effect for CTA
                let scale = 1 + Math.sin(Date.now() / 300) * 0.1;
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2 + 80);
                this.ctx.scale(scale, scale);
                this.ctx.fillText(cta, 0, 0);
                this.ctx.restore();
            }

            drawHUD() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                this.ctx.fillRect(20, 20, 250, 70);
                this.ctx.strokeStyle = '#444';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(20, 20, 250, 70);

                for (let i = 0; i < this.player.maxHealth; i++) {
                    let full = i < this.player.health;
                    this.ctx.fillStyle = full ? COLORS.heart : '#400';
                    this.ctx.beginPath();
                    this.ctx.arc(50 + i * 35, 55, 12, 0, Math.PI * 2);
                    this.ctx.fill();
                    if (full) {
                        this.ctx.shadowColor = '#f00';
                        this.ctx.shadowBlur = 10;
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                }

                // Draw HUD
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '20px Segoe UI';
                this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                this.ctx.fillText(`Level: ${this.levelIndex + 1}`, 20, 60);

                // Health Bar
                this.ctx.fillStyle = '#444';
                this.ctx.fillRect(20, 70, 150, 20);
                this.ctx.fillStyle = '#f00';
                this.ctx.fillRect(20, 70, 150 * (this.player.health / this.player.maxHealth), 20);
                this.ctx.strokeStyle = '#fff';
                this.ctx.strokeRect(20, 70, 150, 20);

                // Ability UI
                if (this.player.activeAbility) {
                    let ab = this.player.activeAbility;
                    let x = 190; let y = 70;

                    this.ctx.fillStyle = '#222';
                    this.ctx.fillRect(x, y, 40, 40);

                    // Cooldown overlay
                    if (ab.cooldownTimer > 0) {
                        let p = ab.cooldownTimer / ab.maxCooldown;
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(x, y + 40 * (1 - p), 40, 40 * p);
                    }

                    this.ctx.strokeStyle = ab.canTrigger() ? '#0ff' : '#666';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(x, y, 40, 40);

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '16px monospace';
                    this.ctx.fillText(ab.icon, x + 12, y + 25);

                    this.ctx.font = '10px Segoe UI';
                    this.ctx.fillStyle = '#aaa';
                    this.ctx.fillText("[SHIFT]", x + 5, y + 55);
                }

                // XP Barthis.ctx.fillText("SCR " + this.score, 250, 75);
            }
        }

        const game = new Game(document.getElementById('gameCanvas'));
        game.startLevel(0); // Initialize here instead

        function loop() {
            game.update();
            game.draw();
            requestAnimationFrame(loop);
        }
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Enter') {
                if (game.state === 'START') {
                    game.setMode('STANDARD');
                    game.startLevel(0);
                    loop(); // Ensure loop is running if stopped? Actually loop runs always.
                } else if (game.state === 'GAME_OVER') {
                    game.player = null;
                    game.state = 'START';
                    game.draw(); // Redraw menu
                }
            }
            if (game.state === 'START') {
                if (e.key === 's' || e.key === 'S') {
                    game.setMode('STANDARD');
                    game.startLevel(0);
                }
                if (e.key === 'd' || e.key === 'D') {
                    game.setMode('DAILY');
                    game.startLevel(0);
                }
                if (e.key === 'e' || e.key === 'E') {
                    game.setMode('ENDLESS');
                    game.startLevel(0);
                }
            }
        });
        loop();
    </script>
</body>

</html>
